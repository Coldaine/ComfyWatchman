"""
Download Manager Module for ComfyFixerSmart

Provides comprehensive download management for model files.
Supports script generation, progress tracking, verification, retry logic,
and state management integration.

Classes:
    DownloadManager: Main download coordinator
    DownloadTask: Individual download task
    DownloadScriptGenerator: Bash script generation

Functions:
    generate_download_script: Create executable download script
    verify_download: Check download integrity
"""

import os
import json
import time
import subprocess
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from datetime import datetime

from .config import config
from .logging import get_logger
from .state_manager import StateManager
from .utils import ensure_directory, get_file_size, validate_url, sanitize_filename


@dataclass
class DownloadTask:
    """Represents a single download task."""

    filename: str
    download_url: str
    target_path: str
    model_type: str
    civitai_id: Optional[int] = None
    version_id: Optional[int] = None
    confidence: str = "exact"
    retry_count: int = 0
    max_retries: int = 3
    status: str = "pending"  # 'pending', 'downloading', 'completed', 'failed'


class DownloadScriptGenerator:
    """
    Generates bash download scripts with verification and state tracking.
    """

    def __init__(self, state_manager: Optional[StateManager] = None, logger=None):
        """
        Initialize the script generator.

        Args:
            state_manager: StateManager instance for tracking
            logger: Optional logger instance
        """
        self.state_manager = state_manager
        self.logger = logger or get_logger("DownloadScriptGenerator")

    def generate_script(
        self, tasks: List[DownloadTask], output_path: str, run_id: Optional[str] = None
    ) -> str:
        """
        Generate a bash download script.

        Args:
            tasks: List of DownloadTask objects
            output_path: Path to save the script
            run_id: Unique run identifier

        Returns:
            Path to the generated script
        """
        if run_id is None:
            run_id = datetime.now().strftime("%Y%m%d_%H%M%S")

        script_lines = self._build_script_header(run_id)
        script_lines.extend(self._build_script_functions())
        script_lines.extend(self._build_download_commands(tasks))
        script_lines.extend(self._build_script_footer())

        # Write script
        script_path = Path(output_path)
        with open(script_path, "w") as f:
            f.write("\n".join(script_lines))

        # Make executable
        script_path.chmod(0o755)

        self.logger.info(f"Generated download script: {script_path}")
        return str(script_path)

    def _build_script_header(self, run_id: str) -> List[str]:
        """Build the script header."""
        return [
            "#!/bin/bash",
            f"# Auto-generated by ComfyFixerSmart - Run ID: {run_id}",
            f"# Generated: {datetime.now()}",
            "",
            "# Load optional secrets (e.g., CIVITAI_API_KEY)",
            "source ~/.secrets 2>/dev/null || true",
            "",
            f'CONFIG_MODELS_DIR="{str(config.models_dir) if config.models_dir else ""}"',
            "# Resolve MODELS_DIR: prefer config, fallback to COMFYUI_ROOT/models",
            'if [ -n "$CONFIG_MODELS_DIR" ]; then',
            '  MODELS_DIR="$CONFIG_MODELS_DIR"',
            'elif [ -n "$COMFYUI_ROOT" ]; then',
            '  MODELS_DIR="$COMFYUI_ROOT/models"',
            "else",
            '  MODELS_DIR=""',
            "fi",
            "",
            "# Validate MODELS_DIR",
            'if [ -z "$MODELS_DIR" ] || [ ! -d "$MODELS_DIR" ]; then',
            "  echo 'Error: MODELS_DIR not set or does not exist.'",
            "  echo 'Set COMFYUI_ROOT or configure comfyui_root so downloads go to ComfyUI/models.'",
            "  exit 1",
            "fi",
            "",
        ]

    def _build_script_functions(self) -> List[str]:
        """Build utility functions for the script."""
        return [
            "# Function to verify download",
            "verify_download() {",
            '  local file="$1"',
            '  local filename="$2"',
            '  local expected_size="$3"',
            "  ",
            '  if [ ! -f "$file" ]; then',
            '    echo "  ✗ File not found: $file"',
            "    return 1",
            "  fi",
            "  ",
            '  local size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)',
            '  if [ "$size" -lt 1000000 ]; then',
            '    echo "  ⚠️  File too small ($size bytes), likely failed"',
            '    rm -f "$file"',
            "    return 1",
            "  fi",
            "  ",
            '  if [ -n "$expected_size" ] && [ "$size" -ne "$expected_size" ]; then',
            '    echo "  ⚠️  Size mismatch (expected: $expected_size, got: $size)"',
            "  fi",
            "  ",
            '  echo "  ✓ Downloaded successfully ($size bytes)"',
            "  return 0",
            "}",
            "",
            "# Function to update state",
            "update_state() {",
            '  local filename="$1"',
            '  local status="$2"',
            '  local file_path="$3"',
            "  ",
            "  if command -v python3 &> /dev/null; then",
            '    python3 -c "',
            "from src.comfyfixersmart.state_manager import StateManager",
            "sm = StateManager()",
            "sm.update_download_status('$filename', '$status', file_path='$file_path')",
            '" 2>/dev/null || true',
            "  fi",
            "}",
            "",
        ]

    def _build_download_commands(self, tasks: List[DownloadTask]) -> List[str]:
        """Build download commands for each task."""
        lines = []

        for task in tasks:
            target_dir = f"${{MODELS_DIR}}/{task.model_type}"
            clean_filename = sanitize_filename(task.filename)
            target_path = f"{target_dir}/{clean_filename}"

            confidence_marker = (
                "⚠️  FUZZY MATCH - VERIFY" if task.confidence == "fuzzy" else "EXACT MATCH"
            )

            lines.extend(
                [
                    f"echo '----------------------------------------'",
                    f"# [{confidence_marker}] {task.filename}",
                    f"echo 'Downloading: {clean_filename}'",
                    f'mkdir -p "{target_dir}"',
                    "",
                    f"wget -c --content-disposition \\",
                    f"  --timeout=60 --tries={task.max_retries} \\",
                    f'  -O "{target_path}" \\',
                    f'  "{task.download_url}"',
                    "",
                    f'if verify_download "{target_path}" "{clean_filename}"; then',
                    f"  echo '  Marking as successful in state'",
                    f'  update_state "{task.filename}" "success" "{target_path}"',
                    f"else",
                    f"  echo '  Download may have failed'",
                    f'  update_state "{task.filename}" "failed" ""',
                    f"fi",
                    "",
                ]
            )

        return lines

    def _build_script_footer(self) -> List[str]:
        """Build the script footer."""
        return [
            "echo '========================================'",
            "echo 'Download complete! Check state with:'",
            "echo '  python3 -c \"from src.comfyfixersmart.state_manager import StateManager; print(StateManager().get_stats())\"'",
            "",
        ]


class DownloadManager:
    """
    Comprehensive download manager for model files.

    Handles download coordination, progress tracking, verification,
    and state management integration.
    """

    def __init__(
        self,
        state_manager: Optional[StateManager] = None,
        output_dir: Optional[str] = None,
        logger=None,
    ):
        """
        Initialize the download manager.

        Args:
            state_manager: StateManager instance for tracking
            output_dir: Directory for output files
            logger: Optional logger instance
        """
        self.state_manager = state_manager
        self.output_dir = Path(output_dir or config.output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.logger = logger or get_logger("DownloadManager")
        self.script_generator = DownloadScriptGenerator(state_manager, logger)

    def create_download_tasks(self, search_results: List[Dict[str, Any]]) -> List[DownloadTask]:
        """
        Create download tasks from search results.

        Args:
            search_results: List of search result dictionaries

        Returns:
            List of DownloadTask objects
        """
        tasks = []

        for result in search_results:
            if result.get("status") != "FOUND" or not result.get("download_url"):
                continue

            task = DownloadTask(
                filename=result["filename"],
                download_url=result["download_url"],
                target_path=self._get_target_path(result),
                model_type=result.get("type", "checkpoints"),
                civitai_id=result.get("civitai_id"),
                version_id=result.get("version_id"),
                confidence=result.get("confidence", "exact"),
            )
            tasks.append(task)

        return tasks

    def _get_target_path(self, result: Dict[str, Any]) -> str:
        """Get the target file path for a download."""
        model_type = result.get("type", "checkpoints")
        filename = sanitize_filename(result["filename"])
        # Ensure we target the actual ComfyUI models directory, not the repo
        models_dir = config.models_dir
        if not models_dir:
            raise ValueError(
                "ComfyUI root is not configured. Set COMFYUI_ROOT env var or comfyui_root in config."
            )
        return str(models_dir / model_type / filename)

    def generate_download_script(
        self, search_results: List[Dict[str, Any]], run_id: Optional[str] = None
    ) -> str:
        """
        Generate a download script from search results.

        Args:
            search_results: List of search result dictionaries
            run_id: Unique run identifier

        Returns:
            Path to the generated script
        """
        tasks = self.create_download_tasks(search_results)

        if not tasks:
            self.logger.warning("No valid download tasks found")
            return ""

        script_path = self.output_dir / f"download_{run_id or 'latest'}.sh"
        return self.script_generator.generate_script(tasks, str(script_path), run_id)

    def execute_download_script(self, script_path: str, timeout: int = 3600) -> bool:
        """
        Execute a download script.

        Args:
            script_path: Path to the download script
            timeout: Maximum execution time in seconds

        Returns:
            True if execution completed successfully
        """
        try:
            self.logger.info(f"Executing download script: {script_path}")

            result = subprocess.run(
                [script_path],
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd=str(self.output_dir),
            )

            if result.returncode == 0:
                self.logger.info("Download script completed successfully")
                return True
            else:
                self.logger.error(f"Download script failed: {result.stderr}")
                return False

        except subprocess.TimeoutExpired:
            self.logger.error(f"Download script timed out after {timeout} seconds")
            return False
        except Exception as e:
            self.logger.error(f"Error executing download script: {e}")
            return False

    def verify_downloads(self, tasks: List[DownloadTask]) -> Dict[str, Any]:
        """
        Verify completed downloads.

        Args:
            tasks: List of DownloadTask objects

        Returns:
            Dictionary with verification results
        """
        results = {"total": len(tasks), "successful": 0, "failed": 0, "missing": 0, "details": []}

        for task in tasks:
            verification = self._verify_single_download(task)
            results["details"].append(verification)

            if verification["status"] == "success":
                results["successful"] += 1
            elif verification["status"] == "missing":
                results["missing"] += 1
            else:
                results["failed"] += 1

        return results

    def _verify_single_download(self, task: DownloadTask) -> Dict[str, Any]:
        """Verify a single download."""
        result = {
            "filename": task.filename,
            "target_path": task.target_path,
            "status": "unknown",
            "size": 0,
            "error": None,
        }

        if not os.path.exists(task.target_path):
            result["status"] = "missing"
            result["error"] = "File not found"
            return result

        try:
            size = get_file_size(task.target_path)
            result["size"] = size or 0

            if size and size > 1_000_000:  # At least 1MB
                result["status"] = "success"
            else:
                result["status"] = "failed"
                result["error"] = f"File too small: {size} bytes"

        except Exception as e:
            result["status"] = "error"
            result["error"] = str(e)

        return result

    def retry_failed_downloads(
        self, tasks: List[DownloadTask], max_retries: int = 3
    ) -> List[DownloadTask]:
        """
        Create retry tasks for failed downloads.

        Args:
            tasks: Original list of DownloadTask objects
            max_retries: Maximum number of retry attempts

        Returns:
            List of retry tasks
        """
        retry_tasks = []

        for task in tasks:
            if task.retry_count >= max_retries:
                continue

            # Check if download failed
            if os.path.exists(task.target_path):
                size = get_file_size(task.target_path)
                if size and size > 1_000_000:
                    continue  # Already successful

            # Create retry task
            retry_task = DownloadTask(
                filename=task.filename,
                download_url=task.download_url,
                target_path=task.target_path,
                model_type=task.model_type,
                civitai_id=task.civitai_id,
                version_id=task.version_id,
                confidence=task.confidence,
                retry_count=task.retry_count + 1,
                max_retries=max_retries,
            )
            retry_tasks.append(retry_task)

        return retry_tasks

    def get_download_stats(self) -> Dict[str, Any]:
        """Get download statistics from state manager."""
        if not self.state_manager:
            return {"error": "No state manager configured"}

        return self.state_manager.get_stats()


# Convenience functions for backward compatibility
def generate_download_script(resolutions, output_dir=None, run_id=None, logger=None):
    """
    Convenience function to generate download script (backward compatibility).

    Args:
        resolutions: List of resolution dictionaries
        output_dir: Output directory
        run_id: Run identifier
        logger: Optional logger

    Returns:
        Path to generated script
    """
    manager = DownloadManager(output_dir=output_dir, logger=logger)
    return manager.generate_download_script(resolutions, run_id)


def verify_download(file_path, filename, expected_size=None, logger=None):
    """
    Convenience function to verify a download (backward compatibility).

    Args:
        file_path: Path to downloaded file
        filename: Original filename
        expected_size: Expected file size
        logger: Optional logger

    Returns:
        True if verification passed
    """
    log = logger or get_logger("verify_download")

    if not os.path.exists(file_path):
        log.error(f"File not found: {file_path}")
        return False

    size = get_file_size(file_path)
    if not size:
        log.error(f"Cannot get file size: {file_path}")
        return False

    if size < 1_000_000:
        log.warning(f"File too small ({size} bytes): {filename}")
        return False

    if expected_size and size != expected_size:
        log.warning(f"Size mismatch (expected: {expected_size}, got: {size}): {filename}")

    log.info(f"✓ Verified: {filename} ({size} bytes)")
    return True

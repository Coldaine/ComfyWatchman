"""
Download Manager Module for ComfyFixerSmart

Provides comprehensive download management for model files.
Supports script generation, progress tracking, verification, retry logic,
and state management integration.

Classes:
    DownloadManager: Main download coordinator
    DownloadTask: Individual download task
    DownloadScriptGenerator: Bash script generation

Functions:
    generate_download_script: Create executable download script
    verify_download: Check download integrity
"""

import os
import subprocess
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

from .config import config
from .logging import get_logger
from .state_manager import StateManager
from .utils import get_file_size, sanitize_filename

# Import batch downloader for direct Python downloads
try:
    from .civitai_tools.batch_downloader import (
        CivitaiBatchDownloader,
        BatchJob,
        BatchStatus,
    )

    BATCH_DOWNLOADER_AVAILABLE = True
except ImportError:
    BATCH_DOWNLOADER_AVAILABLE = False


@dataclass
class DownloadTask:
    """Represents a single download task."""

    filename: str
    download_url: str
    target_path: str
    model_type: str
    civitai_id: Optional[int] = None
    version_id: Optional[int] = None
    confidence: str = "exact"
    retry_count: int = 0
    max_retries: int = 3
    status: str = "pending"  # 'pending', 'downloading', 'completed', 'failed'


class DownloadScriptGenerator:
    """
    Generates bash download scripts with verification and state tracking.
    """

    def __init__(self, state_manager: Optional[StateManager] = None, logger=None):
        """
        Initialize the script generator.

        Args:
            state_manager: StateManager instance for tracking
            logger: Optional logger instance
        """
        self.state_manager = state_manager
        self.logger = logger or get_logger("DownloadScriptGenerator")

    def generate_script(
        self, tasks: List[DownloadTask], output_path: str, run_id: Optional[str] = None
    ) -> str:
        """
        Generate a bash download script.

        Args:
            tasks: List of DownloadTask objects
            output_path: Path to save the script
            run_id: Unique run identifier

        Returns:
            Path to the generated script
        """
        if run_id is None:
            run_id = datetime.now().strftime("%Y%m%d_%H%M%S")

        script_lines = self._build_script_header(run_id)
        script_lines.extend(self._build_script_functions())
        script_lines.extend(self._build_download_commands(tasks))
        script_lines.extend(self._build_script_footer())

        # Write script
        script_path = Path(output_path)
        with open(script_path, "w") as f:
            f.write("\n".join(script_lines))

        # Make executable
        script_path.chmod(0o755)

        self.logger.info(f"Generated download script: {script_path}")
        return str(script_path)

    def _build_script_header(self, run_id: str) -> List[str]:
        """Build the script header."""
        return [
            "#!/bin/bash",
            f"# Auto-generated by ComfyFixerSmart - Run ID: {run_id}",
            f"# Generated: {datetime.now()}",
            "",
            "# Load optional secrets (e.g., CIVITAI_API_KEY)",
            "source ~/.secrets 2>/dev/null || true",
            "",
            f'CONFIG_MODELS_DIR="{str(config.models_dir) if config.models_dir else ""}"',
            "# Resolve MODELS_DIR: prefer config, fallback to COMFYUI_ROOT/models",
            'if [ -n "$CONFIG_MODELS_DIR" ]; then',
            '  MODELS_DIR="$CONFIG_MODELS_DIR"',
            'elif [ -n "$COMFYUI_ROOT" ]; then',
            '  MODELS_DIR="$COMFYUI_ROOT/models"',
            "else",
            '  MODELS_DIR=""',
            "fi",
            "",
            "# Validate MODELS_DIR",
            'if [ -z "$MODELS_DIR" ] || [ ! -d "$MODELS_DIR" ]; then',
            "  echo 'Error: MODELS_DIR not set or does not exist.'",
            "  echo 'Set COMFYUI_ROOT or configure comfyui_root so downloads go to ComfyUI/models.'",
            "  exit 1",
            "fi",
            "",
        ]

    def _build_script_functions(self) -> List[str]:
        """Build utility functions for the script."""
        return [
            "# Function to verify download",
            "verify_download() {",
            '  local file="$1"',
            '  local filename="$2"',
            '  local expected_size="$3"',
            "  ",
            '  if [ ! -f "$file" ]; then',
            '    echo "  ✗ File not found: $file"',
            "    return 1",
            "  fi",
            "  ",
            '  local size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)',
            '  if [ "$size" -lt 1000000 ]; then',
            '    echo "  ⚠️  File too small ($size bytes), likely failed"',
            '    rm -f "$file"',
            "    return 1",
            "  fi",
            "  ",
            '  if [ -n "$expected_size" ] && [ "$size" -ne "$expected_size" ]; then',
            '    echo "  ⚠️  Size mismatch (expected: $expected_size, got: $size)"',
            "  fi",
            "  ",
            '  echo "  ✓ Downloaded successfully ($size bytes)"',
            "  return 0",
            "}",
            "",
            "# Function to update state",
            "update_state() {",
            '  local filename="$1"',
            '  local status="$2"',
            '  local file_path="$3"',
            "  ",
            "  if command -v python3 &> /dev/null; then",
            '    python3 -c "',
            "from src.comfyfixersmart.state_manager import StateManager",
            "sm = StateManager()",
            "sm.update_download_status('$filename', '$status', file_path='$file_path')",
            '" 2>/dev/null || true',
            "  fi",
            "}",
            "",
        ]

    def _build_download_commands(self, tasks: List[DownloadTask]) -> List[str]:
        """Build download commands for each task."""
        lines = []

        for task in tasks:
            target_dir = f"${{MODELS_DIR}}/{task.model_type}"
            clean_filename = sanitize_filename(task.filename)
            target_path = f"{target_dir}/{clean_filename}"

            confidence_marker = (
                "⚠️  FUZZY MATCH - VERIFY" if task.confidence == "fuzzy" else "EXACT MATCH"
            )

            lines.extend(
                [
                    "echo '----------------------------------------'",
                    f"# [{confidence_marker}] {task.filename}",
                    f"echo 'Downloading: {clean_filename}'",
                    f'mkdir -p "{target_dir}"',
                    "",
                    "wget -c --content-disposition \\",
                    f"  --timeout=60 --tries={task.max_retries} \\",
                    f'  -O "{target_path}" \\',
                    f'  "{task.download_url}"',
                    "",
                    f'if verify_download "{target_path}" "{clean_filename}"; then',
                    "  echo '  Marking as successful in state'",
                    f'  update_state "{task.filename}" "success" "{target_path}"',
                    "else",
                    "  echo '  Download may have failed'",
                    f'  update_state "{task.filename}" "failed" ""',
                    "fi",
                    "",
                ]
            )

        return lines

    def _build_script_footer(self) -> List[str]:
        """Build the script footer."""
        return [
            "echo '========================================'",
            "echo 'Download complete! Check state with:'",
            "echo '  python3 -c \"from src.comfyfixersmart.state_manager import StateManager; print(StateManager().get_stats())\"'",
            "",
        ]


class DownloadManager:
    """
    Comprehensive download manager for model files.

    Handles download coordination, progress tracking, verification,
    and state management integration.
    """

    def __init__(
        self,
        state_manager: Optional[StateManager] = None,
        output_dir: Optional[str] = None,
        logger=None,
    ):
        """
        Initialize the download manager.

        Args:
            state_manager: StateManager instance for tracking
            output_dir: Directory for output files
            logger: Optional logger instance
        """
        self.state_manager = state_manager
        self.output_dir = Path(output_dir or config.output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.logger = logger or get_logger("DownloadManager")
        self.script_generator = DownloadScriptGenerator(state_manager, logger)

    def create_download_tasks(self, search_results: List[Dict[str, Any]]) -> List[DownloadTask]:
        """
        Create download tasks from search results.

        Args:
            search_results: List of search result dictionaries

        Returns:
            List of DownloadTask objects
        """
        tasks = []

        for result in search_results:
            if result.get("status") != "FOUND" or not result.get("download_url"):
                continue

            task = DownloadTask(
                filename=result["filename"],
                download_url=result["download_url"],
                target_path=self._get_target_path(result),
                model_type=result.get("type", "checkpoints"),
                civitai_id=result.get("civitai_id"),
                version_id=result.get("version_id"),
                confidence=result.get("confidence", "exact"),
            )
            tasks.append(task)

        return tasks

    def _get_target_path(self, result: Dict[str, Any]) -> str:
        """Get the target file path for a download."""
        model_type = result.get("type", "checkpoints")
        filename = sanitize_filename(result["filename"])
        # Ensure we target the actual ComfyUI models directory, not the repo
        models_dir = config.models_dir
        if not models_dir:
            raise ValueError(
                "ComfyUI root is not configured. Set COMFYUI_ROOT env var or comfyui_root in config."
            )
        return str(models_dir / model_type / filename)

    def generate_download_script(
        self, search_results: List[Dict[str, Any]], run_id: Optional[str] = None
    ) -> str:
        """
        Generate a download script from search results.

        Args:
            search_results: List of search result dictionaries
            run_id: Unique run identifier

        Returns:
            Path to the generated script
        """
        tasks = self.create_download_tasks(search_results)

        if not tasks:
            self.logger.warning("No valid download tasks found")
            return ""

        script_path = self.output_dir / f"download_{run_id or 'latest'}.sh"
        return self.script_generator.generate_script(tasks, str(script_path), run_id)

    def execute_download_script(self, script_path: str, timeout: int = 3600) -> bool:
        """
        Execute a download script.

        Args:
            script_path: Path to the download script
            timeout: Maximum execution time in seconds

        Returns:
            True if execution completed successfully
        """
        try:
            self.logger.info(f"Executing download script: {script_path}")

            result = subprocess.run(
                [script_path],
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd=str(self.output_dir),
            )

            if result.returncode == 0:
                self.logger.info("Download script completed successfully")
                return True
            else:
                self.logger.error(f"Download script failed: {result.stderr}")
                return False

        except subprocess.TimeoutExpired:
            self.logger.error(f"Download script timed out after {timeout} seconds")
            return False
        except Exception as e:
            self.logger.error(f"Error executing download script: {e}")
            return False

    def verify_downloads(self, tasks: List[DownloadTask]) -> Dict[str, Any]:
        """
        Verify completed downloads.

        Args:
            tasks: List of DownloadTask objects

        Returns:
            Dictionary with verification results
        """
        results = {"total": len(tasks), "successful": 0, "failed": 0, "missing": 0, "details": []}

        for task in tasks:
            verification = self._verify_single_download(task)
            results["details"].append(verification)

            if verification["status"] == "success":
                results["successful"] += 1
            elif verification["status"] == "missing":
                results["missing"] += 1
            else:
                results["failed"] += 1

        return results

    def _verify_single_download(self, task: DownloadTask) -> Dict[str, Any]:
        """Verify a single download."""
        result = {
            "filename": task.filename,
            "target_path": task.target_path,
            "status": "unknown",
            "size": 0,
            "error": None,
        }

        if not os.path.exists(task.target_path):
            result["status"] = "missing"
            result["error"] = "File not found"
            return result

        try:
            size = get_file_size(task.target_path)
            result["size"] = size or 0

            if size and size > 1_000_000:  # At least 1MB
                result["status"] = "success"
            else:
                result["status"] = "failed"
                result["error"] = f"File too small: {size} bytes"

        except Exception as e:
            result["status"] = "error"
            result["error"] = str(e)

        return result

    def retry_failed_downloads(
        self, tasks: List[DownloadTask], max_retries: int = 3
    ) -> List[DownloadTask]:
        """
        Create retry tasks for failed downloads.

        Args:
            tasks: Original list of DownloadTask objects
            max_retries: Maximum number of retry attempts

        Returns:
            List of retry tasks
        """
        retry_tasks = []

        for task in tasks:
            if task.retry_count >= max_retries:
                continue

            # Check if download failed
            if os.path.exists(task.target_path):
                size = get_file_size(task.target_path)
                if size and size > 1_000_000:
                    continue  # Already successful

            # Create retry task
            retry_task = DownloadTask(
                filename=task.filename,
                download_url=task.download_url,
                target_path=task.target_path,
                model_type=task.model_type,
                civitai_id=task.civitai_id,
                version_id=task.version_id,
                confidence=task.confidence,
                retry_count=task.retry_count + 1,
                max_retries=max_retries,
            )
            retry_tasks.append(retry_task)

        return retry_tasks

    def get_download_stats(self) -> Dict[str, Any]:
        """Get download statistics from state manager."""
        if not self.state_manager:
            return {"error": "No state manager configured"}

        return self.state_manager.get_stats()

    def download_models_direct(
        self, search_results: List[Dict[str, Any]], run_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Download models directly using Python (CivitaiBatchDownloader).

        This method bypasses script generation and downloads models directly
        with hash verification, proper retry logic, and state tracking.

        Args:
            search_results: List of search result dictionaries
            run_id: Run identifier for logging

        Returns:
            Summary dict with success/failure counts
        """
        if not BATCH_DOWNLOADER_AVAILABLE:
            self.logger.error("CivitaiBatchDownloader not available - cannot perform direct downloads")
            return {
                "error": "Batch downloader not available",
                "successful": 0,
                "failed": 0,
                "total": 0,
            }

        # Convert search results to BatchJob objects
        jobs = []
        for result in search_results:
            # Only process FOUND results with civitai_id
            if result.get("status") != "FOUND" or not result.get("civitai_id"):
                continue

            job = BatchJob(
                model_id=result["civitai_id"],
                model_name=result.get("filename", f"model_{result['civitai_id']}"),
                version_id=result.get("version_id"),
                max_retries=3,
            )
            jobs.append(job)

        if not jobs:
            self.logger.warning("No valid Civitai models to download")
            return {"successful": 0, "failed": 0, "total": 0, "jobs": []}

        self.logger.info(f"Preparing to download {len(jobs)} models via Python")

        # Determine download directory
        # Use config.models_dir if available, otherwise use output_dir
        download_dir = config.models_dir if config.models_dir else self.output_dir

        # Execute batch download
        downloader = CivitaiBatchDownloader(download_dir=str(download_dir), max_retries=3)

        summary = downloader.download_batch(jobs)

        # Update state manager with download results
        if self.state_manager:
            for job in summary.jobs:
                status = "success" if job.status == BatchStatus.COMPLETED else "failed"
                file_path = job.result.file_path if job.result and job.result.file_path else None

                self.state_manager.update_download_status(
                    job.model_name, status, file_path=file_path
                )

        # Convert to dict and return
        result_dict = summary.to_dict()
        self.logger.info(
            f"Direct download complete: {result_dict['successful']} successful, "
            f"{result_dict['failed']} failed"
        )

        return result_dict

    def download_models_automatically(
        self, search_results: List[Dict[str, Any]], run_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        AUTOMATICALLY download models using Python (CivitaiBatchDownloader).

        This replaces the old script generation workflow. Downloads happen
        immediately, with real-time progress, hash verification, and state updates.

        Models are downloaded to the correct subdirectories automatically:
        - ComfyUI/models/checkpoints/ for checkpoints
        - ComfyUI/models/loras/ for LoRAs
        - ComfyUI/models/vae/ for VAEs
        - Uses result.type field to determine folder

        Args:
            search_results: Search results with download info
            run_id: Run identifier for logging

        Returns:
            Summary dict with success/failure counts and file paths
        """
        if not BATCH_DOWNLOADER_AVAILABLE:
            self.logger.error(
                "CivitaiBatchDownloader not available - cannot perform automatic downloads"
            )
            return {
                "error": "Batch downloader not available",
                "successful": 0,
                "failed": 0,
                "total": 0,
            }

        self.logger.info("=== Starting Automatic Downloads ===")

        # Convert search results to BatchJob objects, grouped by target directory
        downloads_by_dir = {}  # {target_dir: [BatchJob, ...]}

        for result in search_results:
            # Only process FOUND results with civitai_id
            if result.get("status") != "FOUND" or not result.get("civitai_id"):
                continue

            # Determine target directory based on model type
            model_type = result.get("type", "checkpoints")
            if not model_type:
                model_type = "checkpoints"

            target_dir = config.models_dir / model_type if config.models_dir else None

            if not target_dir:
                self.logger.error("ComfyUI models directory not configured, cannot download")
                continue

            # Ensure directory exists
            target_dir.mkdir(parents=True, exist_ok=True)

            # Create BatchJob
            job = BatchJob(
                model_id=result["civitai_id"],
                model_name=result.get("filename", f"model_{result['civitai_id']}"),
                version_id=result.get("version_id"),
                max_retries=3,
            )

            # Group by target directory
            target_dir_str = str(target_dir)
            if target_dir_str not in downloads_by_dir:
                downloads_by_dir[target_dir_str] = []
            downloads_by_dir[target_dir_str].append(job)

        if not downloads_by_dir:
            self.logger.warning("No models to download")
            return {"successful": 0, "failed": 0, "skipped": 0, "total": 0}

        # Execute downloads for each target directory
        all_summaries = []
        total_successful = 0
        total_failed = 0
        total_skipped = 0

        for target_dir_str, jobs in downloads_by_dir.items():
            self.logger.info(f"Downloading {len(jobs)} models to {target_dir_str}...")

            # Execute batch download with progress
            downloader = CivitaiBatchDownloader(
                download_dir=target_dir_str, max_retries=3, delay_between_downloads=1.0
            )

            summary = downloader.download_batch(jobs, continue_on_failure=True)

            # Update state manager for each download
            if self.state_manager:
                for job in summary.jobs:
                    if job.result:
                        status = "success" if job.status == BatchStatus.COMPLETED else "failed"
                        file_path = job.result.file_path if job.result.file_path else None
                        self.state_manager.update_download_status(
                            job.model_name, status, file_path=file_path
                        )

            # Accumulate results
            total_successful += summary.successful
            total_failed += summary.failed
            total_skipped += summary.skipped
            all_summaries.append(summary)

        # Log final summary
        self.logger.info("=== Download Summary ===")
        self.logger.info(f"✓ Successful: {total_successful}")
        self.logger.info(f"✗ Failed: {total_failed}")
        self.logger.info(f"⏭ Skipped: {total_skipped}")

        return {
            "successful": total_successful,
            "failed": total_failed,
            "skipped": total_skipped,
            "total": total_successful + total_failed + total_skipped,
            "summaries": [s.to_dict() for s in all_summaries],
        }

    def process_downloads(
        self, search_results: List[Dict[str, Any]], run_id: Optional[str] = None, mode: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Process downloads based on configured mode.

        This is the main entry point for download orchestration. It routes
        to either direct Python downloads or script generation based on mode.

        Args:
            search_results: Search results with download info
            run_id: Run identifier
            mode: Override mode (python|script|both), defaults to config or "python"

        Returns:
            Summary dict with paths/results

        Example:
            results = manager.process_downloads(search_results, run_id="abc123", mode="python")
            # Returns: {"direct_downloads": {...}} for python mode
            # Returns: {"script_path": "..."} for script mode
            # Returns: both keys for "both" mode
        """
        # Determine mode from parameter, config, or default to "python"
        if mode is None:
            # Check if config has download mode (future enhancement)
            mode = getattr(config, "download_mode", "python")

        self.logger.info(f"Processing downloads in mode: {mode}")

        results = {}

        # Execute direct Python downloads
        if mode in ["python", "both"]:
            self.logger.info("Executing direct Python downloads...")
            results["direct_downloads"] = self.download_models_direct(search_results, run_id)

        # Generate download script
        if mode in ["script", "both"]:
            self.logger.info("Generating download script...")
            script_path = self.generate_download_script(search_results, run_id)
            if script_path:
                results["script_path"] = script_path

        return results


# Convenience functions for backward compatibility
def generate_download_script(resolutions, output_dir=None, run_id=None, logger=None):
    """
    Convenience function to generate download script (backward compatibility).

    Args:
        resolutions: List of resolution dictionaries
        output_dir: Output directory
        run_id: Run identifier
        logger: Optional logger

    Returns:
        Path to generated script
    """
    manager = DownloadManager(output_dir=output_dir, logger=logger)
    return manager.generate_download_script(resolutions, run_id)


def verify_download(file_path, filename, expected_size=None, logger=None):
    """
    Convenience function to verify a download (backward compatibility).

    Args:
        file_path: Path to downloaded file
        filename: Original filename
        expected_size: Expected file size
        logger: Optional logger

    Returns:
        True if verification passed
    """
    log = logger or get_logger("verify_download")

    if not os.path.exists(file_path):
        log.error(f"File not found: {file_path}")
        return False

    size = get_file_size(file_path)
    if not size:
        log.error(f"Cannot get file size: {file_path}")
        return False

    if size < 1_000_000:
        log.warning(f"File too small ({size} bytes): {filename}")
        return False

    if expected_size and size != expected_size:
        log.warning(f"Size mismatch (expected: {expected_size}, got: {size}): {filename}")

    log.info(f"✓ Verified: {filename} ({size} bytes)")
    return True
